# SSD Clean Commit: SSD 검증용 테스트 셸

![Python](https://img.shields.io/badge/python한 SSD(Solid State Drive)의 기본 동작(읽기, 쓰기)을 검증하기 위한 강력하고 사용자 친화적인 테스트 셸 애플리케이션입니다.

본 프로젝트는 단순한 기능 구현을 넘어, **클린 코드 원칙**과 **철저한 코드 리뷰 문화**를 바탕으로 협업하며 소프트웨어의 품질을 점진적으로 개선해나가는 과정을 담고 있습니다. 성능보다는 코드의 안정성, 가독성, 유지보수성에 초점을 맞추어 개발되었습니다.

## 👨‍💻 우리 팀, CleanCommit: 역할 및 책임

| 역할 | 이름 | GitHub                                              | 주요 역할                                |
| :--- | :--- |:----------------------------------------------------|:-------------------------------------|
| **팀장** | 정송화 | [@jungsh83](https://github.com/jungsh83)            | 프로젝트 통합, 시나리오 개발 및 리뷰, SSD Driver 리뷰 |
| **팀원** | 나송주 | [@rmsidgo1](https://github.com/rmsidgo1)            | Shell 개발, Commands 리뷰, 통합테스트 케이스 개발  |
| **팀원** | 설서은 | [@seoeun46](https://github.com/seoeun46)            | SSD 개발 및 리뷰, 전체 소스 Refactoring 제안    |
| **팀원** | 권구남 | [@Nueve-Code](https://github.com/Nueve-Code)        | Commands 개발, Shell 리뷰                |
| **팀원** | 우성경 | [@SKWOO-CRA-EDU](https://github.com/SKWOO-CRA-EDU)  | SSD 개발 및 리뷰, Commands 개발 및 리뷰        |
| **팀원** | 지우성 | [@jws9106](https://github.com/jws9106)              | 시나리오 개발 및 리뷰, SSD Driver 개발          |

## 📝 우리의 개발 철학과 프로세스

이 프로젝트는 결과물만큼 과정의 학습을 중요하게 생각합니다. 우리는 아래의 원칙들을 나침반 삼아 개발을 진행했습니다.

### 1. 애자일 스크럼 기반의 반복적 개발
저희는 총 3회의 스크럼(Scrum) 스프린트를 통해 프로젝트를 점진적으로 완성했습니다. 이 과정은 예측 가능성을 높이고 지속적인 품질 검증을 가능하게 했습니다.

*   **1차 스크럼:** 각자 맡은 모듈(Shell, Commands, Driver)의 핵심 기능을 TDD 사이클에 맞춰 독립적으로 개발했습니다.
*   **2차 스크럼:** **최초 소스 코드 통합(Integration)** 을 진행했습니다. 각자 개발한 모듈을 처음으로 결합하고, **1차 통합 테스트**를 수행하여 이질적인 부분들이 서로 잘 맞물려 동작하는지 검증했습니다. 이 단계를 통해 통합 과정에서 발생하는 문제를 조기에 발견하고 해결할 수 있었습니다.
*   **3차 스크럼:** 모든 기능 개발을 완료하고, 최종 안정성을 확보하기 위해 **2차 통합 테스트**를 수행했습니다. 이를 통해 제품의 완성도를 최종적으로 점검하고 배포 가능한 수준의 품질을 확보했습니다.

### 2. 테스트 주도 개발 (TDD) in Action
*   **Red-Green-Refactor**: 우리는 기능 구현에 앞서 항상 실패하는 테스트(`Red`)를 먼저 작성했습니다. 이후 테스트를 통과하는 최소한의 코드(`Green`)를 구현하고, 마지막으로 코드의 구조를 개선(`Refactor`)하는 사이클을 철저히 따랐습니다. `tests/` 디렉토리의 모든 코드는 이러한 노력의 증거입니다.
*   **자신감 있는 개발**: 잘 작성된 테스트 코드는 새로운 기능 추가나 리팩토링 시 발생할 수 있는 잠재적 오류를 빠르게 감지해주는 든든한 안전망이 되어주었습니다.

### 3. 동시 개발을 가능하게 한 Mocking
*   **의존성 분리**: 프로젝트 초기, 우리는 Shell, Commands, SSD Driver 등 각 모듈의 의존성을 분리했습니다. 이는 `pytest-mock` 라이브러리를 통해 가능했습니다.
*   **효율적인 협업**: 예를 들어, Shell 개발자는 아직 완성되지 않은 SSD Driver의 동작을 `mocker`로 가상(mock)하여 자신의 로직을 독립적으로 개발하고 테스트할 수 있었습니다. 이는 팀원 모두가 서로를 기다릴 필요 없이 동시에 작업을 진행할 수 있는 핵심 전략이었습니다.

### 4. 클린 코드와 지속적인 리팩토링
*   **가독성은 곧 유지보수성**: 우리는 변수명 하나, 함수 하나를 만들 때도 '이 코드를 처음 보는 동료가 쉽게 이해할 수 있는가?'를 기준으로 삼았습니다.
*   **응집도 높이고, 결합도 낮추기**: 사용자 입력을 받는 `shell.py`, 명령어 로직을 처리하는 `command_*.py`, 파일 I/O를 담당하는 `ssd_driver.py`로 역할을 명확히 나누어 코드의 복잡도를 낮추고 유지보수성을 높였습니다.
*   **점진적 개선**: 처음부터 완벽한 코드는 없다는 것을 인정하고, 코드 리뷰와 페어 프로그래밍을 통해 꾸준히 더 나은 구조로 코드를 개선해나갔습니다.

## ✨ 주요 기능

*   **인터랙티브 셸 환경**: 사용자가 직접 명령어를 입력하며 SSD 동작을 테스트할 수 있습니다.
*   **기본 SSD 명령어**: `write`, `read` 등 SSD의 핵심 기능을 지원합니다.
*   **고급 유틸리티 명령어**: `fullwrite`, `fullread`로 전체 LBA 영역을 손쉽게 관리합니다.
*   **자동화된 테스트 시나리오**: 복잡한 테스트 케이스를 단일 명령어로 실행하여 검증을 자동화합니다.
*   **견고한 유효성 검사**: 잘못된 명령어와 인자를 사전에 차단하여 런타임 에러를 방지합니다.

## 📂 프로젝트 구조

```
ssd_clean_commit/
├── .github/          # GitHub
│   └── PULL_REQUEST_TEMPLATE.md  # PR Template
├── src/              # 메인 소스 코드
│   ├── __init__.py   # commands 모듈 임포트
│   ├── shell.py      # 테스트 셸 애플리케이션 (Entry Point)
│   ├── ssd_driver.py # SSD 드라이버 (ssd 제어 담당)
│   ├── ssd.py        # SSD 드라이버 (nand.txt 파일 I/O 담당)
│   ├── commands/
│   │   └── *.py      # 각 명령어별 로직 구현
│   └── ...
├── tests/            # 단위 테스트 및 통합 테스트 코드
└── data
    ├── ssd_nand.txt      # SSD 데이터 저장소 (가상 NAND 플래시)
    └── ssd_output.txt    # 읽기 및 에러 결과 출력 파일
```

## 🚀 시작하기

### 사전 요구 사항

*   Python 3.11 이상

### 설치 및 실행

1.  **프로젝트 클론**
    ```bash
    git clone https://github.com/jungsh83/ssd_clean_commit.git
    ```

2.  **프로젝트 디렉토리로 이동**
    ```bash
    cd ssd_clean_commit
    ```

3.  **테스트 셸 실행**
    프로젝트의 최상위 루트 디렉토리에서 아래 명령어를 실행하여 셸을 시작합니다.
    ```bash
    python -m src.shell
    ```
    > **Note:** `-m` 옵션은 파이썬이 프로젝트 구조를 올바르게 인식하여 모듈을 임포트하게 해주는 가장 안정적인 실행 방법입니다.

## 💻 명령어 가이드

셸이 실행되면 `Shell>` 프롬프트가 나타납니다. 여기에 아래 명령어를 입력하여 사용합니다. (대소문자 구분 없음)

### 기본 명령어

| 명령어 | 형식                                 | 설명 |
| :--- |:-----------------------------------| :--- |
| **write** | `write <LBA> <VALUE>`              | 지정된 LBA에 특정 데이터(VALUE)를 씁니다. |
| **read** | `read <LBA>`                       | 지정된 LBA의 데이터를 읽어 `ssd_output.txt`에 기록합니다. |
| **help** | `help`                             | 사용 가능한 모든 명령어와 사용법, 제작자 정보를 출력합니다. |
| **exit** | `exit`                             | 테스트 셸을 종료합니다. |

**인자(Argument) 규칙**
*   `<LBA>`: `0`부터 `99` 사이의 10진수 정수
*   `<VALUE>`: `0x`로 시작하는 10자리 16진수 문자열 (예: `0x1234ABCD`)

### 유틸리티 명령어

| 명령어 | 형식                  | 설명 |
| :--- |:--------------------| :--- |
| **fullwrite** | `fullwrite <VALUE>` | `0`번부터 `99`번까지 모든 LBA를 지정된 VALUE로 채웁니다. |
| **fullread** | `fullread`          | `0`번부터 `99`번까지 모든 LBA의 데이터를 순차적으로 읽습니다. |

### ⛔ 에러 처리

유효하지 않은 명령어, LBA 범위 초과, 잘못된 값 형식 등 모든 오류 발생 시 `Invalid command` 메시지가 출력되며, 셸은 종료되지 않고 다음 명령을 대기합니다.

## 🧪 테스트 시나리오

미리 정의된 복잡한 테스트 시나리오를 간편하게 실행할 수 있습니다.

| 명령어 | 설명 |
| :--- | :--- |
| **`1_`** 또는 **`1_fullwriteandreadcompare`** | 5개 LBA 단위로 쓰기와 읽기/비교를 반복하며 전체 영역을 검증합니다. |
| **`2_`** 또는 **`2_partiallbawrite`** | 무작위 순서로 특정 LBA에 쓰고, 모든 데이터가 정상적으로 저장되었는지 30회 반복하여 검증합니다. |
| **`3_`** 또는 **`3_writereadaging`** | 맨 앞과 맨 뒤 LBA에 랜덤 값을 쓰고 읽는 동작을 200회 반복하여 데이터 안정성을 테스트합니다. |

*시나리오 실행 중 오류가 발생하면 즉시 `FAIL`을 출력하고 중단됩니다. 모든 과정이 정상이면 `PASS`를 출력합니다.*

## 📝 개발 철학

*   **Clean Code**: 모든 코드는 가독성, 단순성, 유지보수성을 최우선으로 고려하여 작성합니다.
*   **Code Review**: 모든 변경 사항은 팀원의 코드 리뷰를 거쳐 병합함으로써 집단 지성을 활용하고 잠재적 결함을 최소화합니다.
*   **Test-Driven Development (TDD)**: `tests` 디렉토리의 단위 테스트를 통해 코드의 안정성을 확보하고, 리팩토링의 기반을 마련합니다.
*   **점진적 개선**: 처음부터 완벽한 설계를 추구하기보다, 동작하는 작은 단위로 시작하여 지속적인 리팩토링을 통해 더 나은 구조로 발전시킵니다.
